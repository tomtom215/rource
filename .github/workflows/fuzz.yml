name: Fuzzing

on:
  # Run weekly on Sunday at 2 AM UTC
  schedule:
    - cron: '0 2 * * 0'
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      duration:
        description: 'Fuzzing duration per target (seconds)'
        required: false
        default: '3600'
        type: string
  # Run on security-related file changes
  pull_request:
    branches: [main]
    paths:
      - 'crates/rource-vcs/**/*.rs'
      - 'fuzz/**'
      - '.github/workflows/fuzz.yml'

# Prevent concurrent fuzzing runs
concurrency:
  group: fuzzing-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel fuzzing runs

permissions:
  contents: write  # For pushing coverage reports
  security-events: write  # For security alerts

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  fuzz:
    name: Fuzz VCS Parsers
    runs-on: ubuntu-latest
    timeout-minutes: 180  # 3 hour timeout for weekly runs
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: llvm-tools-preview

      - name: Cache cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v1-rust"
          shared-key: "fuzz"
          workspaces: "fuzz -> target"

      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz --locked

      - name: Determine fuzzing duration
        id: duration
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            DURATION="${{ inputs.duration }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            DURATION="300"  # 5 minutes for PRs
          else
            DURATION="3600"  # 1 hour for scheduled runs
          fi
          echo "duration=$DURATION" >> $GITHUB_OUTPUT
          echo "Fuzzing duration: ${DURATION}s per target"

      - name: Run fuzzing
        id: fuzz
        run: |
          cd fuzz

          # Get list of targets
          TARGETS=$(cargo +nightly fuzz list 2>/dev/null)
          echo "Targets: $TARGETS"

          TOTAL_CRASHES=0
          CRASH_DETAILS=""

          for target in $TARGETS; do
            echo ""
            echo "=========================================="
            echo "Fuzzing: $target"
            echo "Duration: ${{ steps.duration.outputs.duration }}s"
            echo "=========================================="

            # Run fuzzer
            set +e
            cargo +nightly fuzz run "$target" -- \
              -max_total_time=${{ steps.duration.outputs.duration }} \
              -print_final_stats=1 \
              2>&1 | tee "fuzz-output-$target.txt"
            FUZZ_EXIT=$?
            set -e

            # Count crashes
            CRASHES=$(find "artifacts/$target" -type f 2>/dev/null | wc -l || echo "0")
            TOTAL_CRASHES=$((TOTAL_CRASHES + CRASHES))

            if [ "$CRASHES" -gt 0 ]; then
              CRASH_DETAILS="${CRASH_DETAILS}\n- $target: $CRASHES crash(es)"
            fi

            # Collect corpus stats
            CORPUS_SIZE=$(find "corpus/$target" -type f 2>/dev/null | wc -l || echo "0")
            echo "Corpus size: $CORPUS_SIZE"
          done

          cd ..

          echo "total_crashes=$TOTAL_CRASHES" >> $GITHUB_OUTPUT
          echo "crash_details=$CRASH_DETAILS" >> $GITHUB_OUTPUT

          # Fail if crashes were found
          if [ "$TOTAL_CRASHES" -gt 0 ]; then
            echo "::error::Fuzzing found $TOTAL_CRASHES crash(es)!"
            exit 1
          fi

      - name: Generate coverage report
        if: always()
        run: |
          cd fuzz

          mkdir -p coverage-report

          for target in $(cargo +nightly fuzz list 2>/dev/null); do
            echo "Generating coverage for $target..."
            set +e
            cargo +nightly fuzz coverage "$target" 2>/dev/null
            set -e
          done

          cd ..

      - name: Collect fuzzing metrics
        if: always()
        run: |
          cd fuzz

          # Generate metrics JSON
          cat > coverage-metrics.json << 'JSONHEADER'
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "event": "${{ github.event_name }}",
            "duration_per_target": ${{ steps.duration.outputs.duration }},
            "targets": [
          JSONHEADER

          FIRST=true
          for target in $(cargo +nightly fuzz list 2>/dev/null); do
            CORPUS_SIZE=$(find "corpus/$target" -type f 2>/dev/null | wc -l || echo "0")
            CRASHES=$(find "artifacts/$target" -type f 2>/dev/null | wc -l || echo "0")

            if [ "$FIRST" != "true" ]; then
              echo "    ," >> coverage-metrics.json
            fi
            FIRST=false

            cat >> coverage-metrics.json << EOF
              {
                "name": "$target",
                "corpus_size": $CORPUS_SIZE,
                "crashes": $CRASHES
              }
          EOF
          done

          cat >> coverage-metrics.json << 'JSONFOOTER'
            ]
          }
          JSONFOOTER

          cd ..

      - name: Generate summary
        if: always()
        run: |
          echo "## Fuzzing Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Event**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Duration**: ${{ steps.duration.outputs.duration }}s per target" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.fuzz.outputs.total_crashes }}" -gt 0 ]; then
            echo "### WARN: Crashes Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Total crashes: **${{ steps.fuzz.outputs.total_crashes }}**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.fuzz.outputs.crash_details }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "### PASS: No Crashes Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All fuzz targets completed without finding crashes." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Corpus Statistics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Target | Corpus Size |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------------|" >> $GITHUB_STEP_SUMMARY

          cd fuzz
          for target in $(cargo +nightly fuzz list 2>/dev/null); do
            CORPUS_SIZE=$(find "corpus/$target" -type f 2>/dev/null | wc -l || echo "0")
            echo "| $target | $CORPUS_SIZE inputs |" >> $GITHUB_STEP_SUMMARY
          done
          cd ..

      - name: Upload crash artifacts
        uses: actions/upload-artifact@v6
        if: failure()
        with:
          name: fuzz-crashes
          path: |
            fuzz/artifacts/
            fuzz/fuzz-output-*.txt
          retention-days: 30

      - name: Upload coverage metrics
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: fuzz-metrics
          path: |
            fuzz/coverage-metrics.json
            fuzz/coverage-report/
          retention-days: 90

      - name: Create security advisory (on crash)
        if: failure() && github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          script: |
            const crashes = parseInt('${{ steps.fuzz.outputs.total_crashes }}') || 0;
            if (crashes > 0) {
              // Create an issue for the crash
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `[Security] Fuzzing found ${crashes} crash(es)`,
                body: `## Fuzzing Crash Report

            **Date**: ${new Date().toISOString()}
            **Crashes Found**: ${crashes}

            ### Details

            The weekly fuzzing run found potential crashes in the VCS parsers.

            ### Action Required

            1. Download the crash artifacts from the [workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }})
            2. Reproduce the crash locally with \`cargo +nightly fuzz run <target> fuzz/artifacts/<target>/<input>\`
            3. Minimize the input with \`cargo +nightly fuzz tmin <target> <input>\`
            4. Fix the issue and add a regression test

            ### Severity Assessment

            Please assess the severity and determine if this requires a security advisory.
            `,
                labels: ['security', 'fuzzing', 'bug']
              });
            }

  # Summary job for required status check
  fuzz-status:
    name: Fuzzing Status
    runs-on: ubuntu-latest
    needs: [fuzz]
    if: always()
    steps:
      - name: Check fuzz results
        run: |
          if [ "${{ needs.fuzz.result }}" = "failure" ]; then
            echo "::error::Fuzzing found crashes - see fuzz job for details"
            exit 1
          fi
          echo "Fuzzing completed successfully"
