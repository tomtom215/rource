# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright (C) 2026 Tom F <https://github.com/tomtom215>
#
# Fuzzing CI workflow for Rource VCS parsers.
#
# Targets: fuzz_git_parser, fuzz_custom_parser, fuzz_svn_parser
# (defined in fuzz/Cargo.toml)
#
# Uses cargo-fuzz (libFuzzer) with corpus caching for incremental
# effectiveness across runs.

name: Fuzzing

on:
  # Run weekly on Sunday at 2 AM UTC
  schedule:
    - cron: '0 2 * * 0'
  # Allow manual trigger
  workflow_dispatch:
    inputs:
      duration:
        description: 'Fuzzing duration per target (seconds)'
        required: false
        default: '3600'
        type: string
  # Run on security-related file changes
  pull_request:
    branches: [main]
    paths:
      - 'crates/rource-vcs/**/*.rs'
      - 'fuzz/**'
      - '.github/workflows/fuzz.yml'

# Prevent concurrent fuzzing runs
concurrency:
  group: fuzzing-${{ github.ref }}
  cancel-in-progress: false  # Don't cancel fuzzing runs

permissions:
  contents: write  # For pushing coverage reports
  security-events: write  # For security alerts
  issues: write  # For creating crash issues

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  fuzz:
    name: Fuzz VCS Parsers
    runs-on: ubuntu-latest
    # Budget: build (~10min) + 3 targets × duration + coverage (~10min) + buffer
    # Default scheduled: 10 + 3×60 + 10 + 10 = 210 min
    # PR: 10 + 3×5 + 10 + 10 = 45 min
    # Manual: depends on input duration
    timeout-minutes: 240
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: llvm-tools-preview

      - name: Cache cargo dependencies
        uses: Swatinem/rust-cache@v2
        with:
          prefix-key: "v1-rust"
          shared-key: "fuzz"
          workspaces: "fuzz -> target"

      # Cache fuzz corpora across runs for incremental effectiveness.
      # A warm corpus lets the fuzzer reach deeper code paths faster.
      - name: Cache fuzz corpora
        uses: actions/cache@v4
        with:
          path: fuzz/corpus
          key: fuzz-corpus-${{ github.ref_name }}-${{ github.run_id }}
          restore-keys: |
            fuzz-corpus-${{ github.ref_name }}-
            fuzz-corpus-main-
            fuzz-corpus-

      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz --locked

      - name: Validate fuzz targets
        run: |
          cd fuzz
          TARGETS=$(cargo +nightly fuzz list 2>&1)
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "::error::cargo fuzz list failed (exit $EXIT_CODE): $TARGETS"
            exit 1
          fi
          TARGET_COUNT=$(echo "$TARGETS" | wc -l)
          if [ "$TARGET_COUNT" -lt 1 ] || [ -z "$TARGETS" ]; then
            echo "::error::No fuzz targets found in fuzz/Cargo.toml"
            exit 1
          fi
          echo "Found $TARGET_COUNT fuzz targets:"
          echo "$TARGETS"

      - name: Determine fuzzing duration
        id: duration
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            DURATION="${{ inputs.duration }}"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            DURATION="300"  # 5 minutes for PRs
          else
            DURATION="3600"  # 1 hour for scheduled runs
          fi
          echo "duration=$DURATION" >> "$GITHUB_OUTPUT"
          echo "Fuzzing duration: ${DURATION}s per target"

      - name: Run fuzzing
        id: fuzz
        run: |
          cd fuzz

          # Get list of targets (already validated above)
          TARGETS=$(cargo +nightly fuzz list)
          echo "Targets: $TARGETS"

          TOTAL_CRASHES=0
          CRASH_TARGETS=""

          for target in $TARGETS; do
            echo ""
            echo "=========================================="
            echo "Fuzzing: $target"
            echo "Duration: ${{ steps.duration.outputs.duration }}s"
            echo "=========================================="

            # Ensure corpus directory exists (for first run without cache)
            mkdir -p "corpus/$target"

            # Run fuzzer
            set +e
            cargo +nightly fuzz run "$target" -- \
              -max_total_time=${{ steps.duration.outputs.duration }} \
              -print_final_stats=1 \
              2>&1 | tee "fuzz-output-$target.txt"
            FUZZ_EXIT=$?
            set -e

            # Count crashes
            CRASHES=$(find "artifacts/$target" -type f 2>/dev/null | wc -l)
            CRASHES=${CRASHES:-0}
            TOTAL_CRASHES=$((TOTAL_CRASHES + CRASHES))

            if [ "$CRASHES" -gt 0 ]; then
              if [ -n "$CRASH_TARGETS" ]; then
                CRASH_TARGETS="${CRASH_TARGETS}|${target}:${CRASHES}"
              else
                CRASH_TARGETS="${target}:${CRASHES}"
              fi
            fi

            # Extract libfuzzer stats from output
            EXECS=$(grep -oP 'stat::number_of_executed_units:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "0")
            NEW_UNITS=$(grep -oP 'stat::new_units_added:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "0")
            PEAK_RSS=$(grep -oP 'stat::peak_rss_mb:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "0")

            # Collect corpus stats
            CORPUS_SIZE=$(find "corpus/$target" -type f 2>/dev/null | wc -l)
            CORPUS_SIZE=${CORPUS_SIZE:-0}

            echo "--- Stats for $target ---"
            echo "  Corpus size: $CORPUS_SIZE"
            echo "  Executions: $EXECS"
            echo "  New units: $NEW_UNITS"
            echo "  Peak RSS: ${PEAK_RSS}MB"
            echo "  Crashes: $CRASHES"
            echo "  Exit code: $FUZZ_EXIT"
          done

          cd ..

          echo "total_crashes=$TOTAL_CRASHES" >> "$GITHUB_OUTPUT"
          echo "crash_targets=$CRASH_TARGETS" >> "$GITHUB_OUTPUT"

          # Fail if crashes were found
          if [ "$TOTAL_CRASHES" -gt 0 ]; then
            echo "::error::Fuzzing found $TOTAL_CRASHES crash(es)!"
            exit 1
          fi

      - name: Generate coverage report
        if: always()
        run: |
          cd fuzz

          mkdir -p coverage-report

          TARGETS=$(cargo +nightly fuzz list 2>/dev/null || true)
          for target in $TARGETS; do
            echo "Generating coverage for $target..."
            if ! cargo +nightly fuzz coverage "$target" 2>&1; then
              echo "::warning::Coverage generation failed for $target"
            fi
          done

          cd ..

      - name: Collect fuzzing metrics
        if: always()
        run: |
          cd fuzz

          TARGETS=$(cargo +nightly fuzz list 2>/dev/null || true)

          # Use Python for reliable JSON generation (no heredoc escaping issues)
          python3 << 'PYEOF'
          import json, os, subprocess, glob

          targets = os.popen("cargo +nightly fuzz list 2>/dev/null").read().strip().split("\n")
          targets = [t.strip() for t in targets if t.strip()]

          target_data = []
          for t in targets:
              corpus_files = glob.glob(f"corpus/{t}/*")
              corpus_size = len(corpus_files)
              artifact_files = glob.glob(f"artifacts/{t}/*")
              crashes = len(artifact_files)

              # Extract libfuzzer stats from output file
              execs = 0
              new_units = 0
              peak_rss = 0
              output_file = f"fuzz-output-{t}.txt"
              if os.path.exists(output_file):
                  with open(output_file) as f:
                      for line in f:
                          if "stat::number_of_executed_units:" in line:
                              try: execs = int(line.split(":")[-1].strip())
                              except: pass
                          elif "stat::new_units_added:" in line:
                              try: new_units = int(line.split(":")[-1].strip())
                              except: pass
                          elif "stat::peak_rss_mb:" in line:
                              try: peak_rss = int(line.split(":")[-1].strip())
                              except: pass

              target_data.append({
                  "name": t,
                  "corpus_size": corpus_size,
                  "crashes": crashes,
                  "executions": execs,
                  "new_units_added": new_units,
                  "peak_rss_mb": peak_rss
              })

          from datetime import datetime, timezone
          metrics = {
              "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ"),
              "event": os.environ.get("GITHUB_EVENT_NAME", "unknown"),
              "duration_per_target": int(os.environ.get("FUZZ_DURATION", "0")),
              "target_count": len(targets),
              "targets": target_data
          }

          with open("coverage-metrics.json", "w") as f:
              json.dump(metrics, f, indent=2)

          print(json.dumps(metrics, indent=2))
          PYEOF

          cd ..
        env:
          FUZZ_DURATION: ${{ steps.duration.outputs.duration }}

      - name: Generate summary
        if: always()
        run: |
          {
            echo "## Fuzzing Results"
            echo ""
            echo "**Event**: ${{ github.event_name }}"
            echo "**Duration**: ${{ steps.duration.outputs.duration }}s per target"
            echo ""

            TOTAL_CRASHES="${{ steps.fuzz.outputs.total_crashes }}"
            CRASH_TARGETS="${{ steps.fuzz.outputs.crash_targets }}"

            if [ -n "$TOTAL_CRASHES" ] && [ "$TOTAL_CRASHES" -gt 0 ] 2>/dev/null; then
              echo "### WARN: Crashes Found"
              echo ""
              echo "Total crashes: **${TOTAL_CRASHES}**"
              echo ""
              # Parse pipe-delimited crash targets (target:count|target:count)
              if [ -n "$CRASH_TARGETS" ]; then
                echo "| Target | Crashes |"
                echo "|--------|---------|"
                echo "$CRASH_TARGETS" | tr '|' '\n' | while IFS=: read -r tgt cnt; do
                  echo "| $tgt | $cnt |"
                done
              fi
            else
              echo "### PASS: No Crashes Found"
              echo ""
              echo "All fuzz targets completed without finding crashes."
            fi

            echo ""
            echo "### Corpus Statistics"
            echo ""
            echo "| Target | Corpus Size | Executions | New Units | Peak RSS |"
            echo "|--------|-------------|------------|-----------|----------|"
          } >> "$GITHUB_STEP_SUMMARY"

          cd fuzz
          for target in $(cargo +nightly fuzz list 2>/dev/null || true); do
            CORPUS_SIZE=$(find "corpus/$target" -type f 2>/dev/null | wc -l)
            CORPUS_SIZE=${CORPUS_SIZE:-0}

            # Extract stats from output file
            EXECS=$(grep -oP 'stat::number_of_executed_units:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "?")
            NEW_UNITS=$(grep -oP 'stat::new_units_added:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "?")
            PEAK_RSS=$(grep -oP 'stat::peak_rss_mb:\s*\K[0-9]+' "fuzz-output-$target.txt" 2>/dev/null || echo "?")

            echo "| $target | $CORPUS_SIZE inputs | $EXECS | $NEW_UNITS | ${PEAK_RSS}MB |" >> "$GITHUB_STEP_SUMMARY"
          done
          cd ..

      - name: Upload crash artifacts
        uses: actions/upload-artifact@v6
        if: failure()
        with:
          name: fuzz-crashes
          path: |
            fuzz/artifacts/
            fuzz/fuzz-output-*.txt
          retention-days: 30

      - name: Upload coverage metrics
        uses: actions/upload-artifact@v6
        if: always()
        with:
          name: fuzz-metrics
          path: |
            fuzz/coverage-metrics.json
            fuzz/coverage-report/
          retention-days: 90

      - name: Create issue on crash (scheduled runs only)
        if: failure() && github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          script: |
            const crashes = parseInt('${{ steps.fuzz.outputs.total_crashes }}') || 0;
            if (crashes === 0) return;

            const crashTargets = '${{ steps.fuzz.outputs.crash_targets }}';
            const details = crashTargets.split('|').filter(Boolean).map(entry => {
              const [target, count] = entry.split(':');
              return `- **${target}**: ${count} crash(es)`;
            }).join('\n');

            const body = [
              '## Fuzzing Crash Report',
              '',
              `**Date**: ${new Date().toISOString()}`,
              `**Crashes Found**: ${crashes}`,
              '',
              '### Affected Targets',
              '',
              details,
              '',
              '### Action Required',
              '',
              `1. Download the crash artifacts from the [workflow run](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
              '2. Reproduce the crash locally with `cargo +nightly fuzz run <target> fuzz/artifacts/<target>/<input>`',
              '3. Minimize the input with `cargo +nightly fuzz tmin <target> <input>`',
              '4. Fix the issue and add a regression test',
              '',
              '### Severity Assessment',
              '',
              'Please assess the severity and determine if this requires a security advisory.',
            ].join('\n');

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[Security] Fuzzing found ${crashes} crash(es)`,
              body: body,
              labels: ['security', 'fuzzing', 'bug']
            });

  # Summary job for required status check
  fuzz-status:
    name: Fuzzing Status
    runs-on: ubuntu-latest
    needs: [fuzz]
    if: always()
    steps:
      - name: Check fuzz results
        run: |
          if [ "${{ needs.fuzz.result }}" = "failure" ]; then
            echo "::error::Fuzzing found crashes - see fuzz job for details"
            exit 1
          fi
          echo "Fuzzing completed successfully"
